# Flexible Arduino Due based arbitrary signal generator
I have often during product development that complex test signals are needed beyond those available from the signal or function generators available in my lab. Commercial arbitrary signal generators (ARB) consisting of a fast memory coupled to a digital-to-analogue converter (DAC) are available, but often do not offer the right mix of analog and digital outputs in a suitably flexible form. This has often been a problem during my day job where I have needed to drive a high efficiency radio frequency (RF) power amplifiers (PA) or transmitters with two analogue outputs for the in-phase (I) and quadrature (Q) inputs of an RF modulator and several digital outputs for switching parts of the transmitter. [Previous work used an ARB platform developed around an Arduino Mega2560](https://www.researchgate.net/publication/361063526_A_Digital_Power_Amplifier_for_32-QAM). This was limited to a sample rate of 457kS/s. To increase the sample rate a new ARB has been developed based on an Arduino Due offering up to 8.4MS/s.

The Arduino Due is based on the 32-bit ATSAM3X8E allowing multiple 8-bit DACs and digital outputs to be mapped onto a single port. This ensuring all DAC or digital outputs update at the same time and only a single LUT is call for every update. The Arduino Due also runs at a higher clock rate of 84 MHz. Although 32-bit, none of the four ports (A to D) available on the ATSAM3X8E’s pins map to all 32-bits. Of the four ports, C with 24-bits available is the most useful. These 24 bits in this project are connected to two 8-bit DACs and one 8-bit digital port. However, they could for example drive two 12-bit DACs or any such combination.

# Testing the Arduino Due
The first thing anyone looks at with an ARB is the sampling rate. In a software based ARB like this (as oppose to an FPGA implmentation) the microprocessor much fetch the output samples from memory and present them to the port with the DAC. This takes several instruction cycles as can be seen in the code "Arb12.ino" where the counter "count" is incremented, masked to stop it overflowing and then used to access a memory location and send it to a port. As this is a repeating operation a goto is used to return to the start. This operation takes 10 instruction cycles, resulting in the 8.4 MS/s for the 84 MHz Arduino Due.

# DACs
The most important part of any ARB are the DACs. For this I settle on the DAC0801. Although quite old, they are readily available and easy to interface. Their datasheet quotes a settling time of 100ns consisting of the DAC slewing time and that for any ringing at the output to settle. The slewing time is a factor of the DAC output current and its load impedance. This suggests a maximum sample rate of 10 MS/s, which fits well with the 8.4 MS/s of the Due. The DAC0801 has complementary current sink outputs (pins 2 and 4). The datasheet suggests op-amp active current to voltage (I/V) converters as an output stage. This was found to introduce excess ringing, so passive resistive I/V converters were used instead. With a 1kΩ resistive load (RL) the slew rate was 30V/μs equivalent to a rise and fall time of 42ns. 

The DAC (IC1 and IC3) and op-amp (IC2 and IC4) interface is shown in the schematic which is given both in the original Eagle format and a png. The peak output current of the DAC0801 is set at 2.13mA by the 4k7 resistors on pins 14 and 15 (R10, R14, R19 and R20) when a ±10V power supply is used. A 1k1 resistor tied to 0V and two 4k7 resistors in series (9k4) to +10 V positive supply rail add an offset so the output voltage at pin 4 swings positive and negative around 0V. This is a high impedance port so an op-amp with a gain of 2V/V buffers the output to drive 2V peak-to-peak into a 50Ω load. In the prototype a TL071 proved optimal in terms of bandwidth and ringing. The TL071 has a unity gain bandwidth product of 3MHz, reduced to 1.5MHz with a gain of 2V/V. Other op-amps may provide a better combination of bandwidth, slew rate and output current.

# Code
The Arduino Due can be programmed in the usual Arduino IDE, but has a unique set of instructions which allows direct port access. The following commands setup port C of the Due for direct access: PIOC→PIO_PER and PIOC→PIO_OER. The command PIOC→PIO_ODSR is then used to write data to the port. A goto loop sends data from the LUT to Port C runs in the setup, as using the main Void loop incurs various overheads including the I/O system to check the serial port. The result is 10 instructions and 8.4MS/s output rate. The LUT allocations are accessed by the variable count which is a 32-bit integer. This is masked (by ANDing) with FF (256) in the sinewave example, 1FF (512) in the triple test example and 4FFF (16384) for the 4G Long Term Evolution (LTE) signal example. Restricting the LUT to powers of 2 simplifies (and hence speeds up) the code. For other values an IF or FOR loop could be used to reset count at any value. A noInterrupts command to disable interrupts is included as without it jitter was noted on the output waveform suggesting the compiler sets some interrupts by default. If a lower sample frequency is desired though, the delayMicroseconds command can be included. In this case noInterrupts should be commented out.

# Data Generation
The data for all ports and the trigger signal are stored in a single LUT (Portvalues in the code). For Port C, the bits that are available on the external pins are: bits 1-8 for Ch A DAC, bits 12-19 for Ch B DAC, bits 21-26 for the digital interface and bit 28 as a trigger. These are generated individually and then mapped into a 32bit word by multiplying the individual values by an offset and adding them together, for example:

Word32 = 2^28*Trigger + 2^21*Digital + 2^12*DAC2 + 2*DAC1

# Tool Chain 
The first two examples were generated in an OpenOffice spreadsheet (File "Signal Gen3.ods) as the LUTs were not very big. The third example was in Python ( due to the resulting LUT size. If using a spreadsheet the data will be generated in a single column. This can be copy and pasted directly into the Arduino IDE as a single column array. It is often more practical though to do this as a 2D array. The values from different cells can be combined with commas as a string into a single cell using the “&” function. In the sinewave example where the values of column Y are to be reformatted into a 16 column by 16 row for 256 values the following is used:

=Y2 & " , " & Y3 & ", " & Y4 & ", " & Y5 & ", " & Y6 & ", " & Y7 & ", " & Y8 & ", " & Y9 & ", " & Y10 & ", " & Y11 & ", " & Y12 & ", " & Y13 & ", " & Y14 & ", " & Y15 & ", " & Y16 & ", " & Y17 & ", "

Using the autofill function will not appropriately increment the Y column values, so there is still quite a bit of manual processing to be done, which is why for larger arrays it is appropriate to use Python. The Python code reads in the File "1M4LTE.txt" 

# Hardware Implementation
To verify the concept, an Arduino Due “shield” was produced. This was fabricated on standard FR4 substrate using through hole DIL components. DIL components incur stray inductance and capacitance when operating in the MHz region, but allow the design to be easily modified. A surface mount implementation would probably produce better results than those presented here. 

# Examples

The code listed in Figure 3 generates two quadrature sine waves on the two DAC outputs (Ch A and Ch B) at 32.8125kHz (8.4MS/s / 256). count is incremented by 1 on each iteration. Increasing the increment value would increase the sine wave frequency similar to direct digital synthesis [3]. 


A screen capture of the two quadrature outputs generated by the code in Figure 3 is shown in Figure 4. There is no output lowpass filter after the DACs other than the frequency response of the TL071. Additional passive filtering would reduce the output switching noise. 

More complex waveforms than sinusoid waves can also be generated, for example the baseband complex data for a 1.4MHz LTE signal consisting of 16384 32-bit words (64kbytes). This signal was processed in Python into an array of 1024 rows and 16 comma separated columns. The 1.4MHz LTE signal has a sample rate of 7.68MS/s. An additional instruction was included in the Arduino loop, resulting 11 instructions and a sample rate of 7.64MS/s. Further, count was ANDed with 4FFF. The frequency domain of the in-phase (I) baseband signal in Figure 5.

The 1.4MHz LTE signal includes guard channels, resulting in an actual RF bandwidth is 1.08MHz (consisting of six 180kHz resource blocks). The baseband bandwidth is half this, 504kHz as clearly shown in Figure 5. There is substantial spectral regrowth in Figure 5 partially due to DAC non-linearities and also spurious products introduced by the system. 

Another ARB application is to directly synthesize modulated RF carriers without any up-conversion. This is often promoted with very high speed (>10 GS/s) ARBs for generating signals with multi GHz bandwidth at GHz carrier frequencies [4]. A simpler example is shown in Figure 6, for a triple tone test. The three tone frequencies are 984.375 kHz, 1.00078125 MHz and 1.0171875 MHz. These three resulting frequencies (Fr) were calculated with:

Fr = Fs * n / LUTs

Where Fs is the sampling frequency, n a whole number to avoid discontinuities – reducing spurious produces – and LUTs the LUT size. Here, Fs was 8.4MS/s, n: 60, 61 and 62, and LUTs 512. Figure 6 shows the spectrum. Even with all the harmonically related spurious products, they are -38dB relative to the three tones. A higher resolution DAC would offer greater dynamic range, and hence lower spurious products [5]. 

Conclusion
A technique using an Arduino Due to generate arbitrary waveforms with multiple analogue and digital outputs is discussed in this article. This is seen as a starting point for discussion of what is possible with low-cost hobbyist level electronic development boards. Promising results are presented for the generation of sinusoid waves, a LTE 4G baseband signals and a three tone tests. 
Alternative platforms running at higher clock frequencies like the Arduino Portenta H7, Raspberry Pi RP2040, Raspberry Pi Zero 2 W or ESP32 could provide higher sampling frequencies and better results. Similarly, so could higher resolution DACs and better op-amp buffers. The next phase of this research is to combine the LTE signal generator with a low-cost quadrature modulator development board to generate 4G signals for testing transmitter architectures.
